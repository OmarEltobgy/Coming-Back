#include <iostream>
#include <stdio.h>
#include <vector>
#include <queue>
#include <string>
#include <string.h>
#include <stdlib.h>
#include <map>
#include <functional>
#include <stack>
#include <math.h>
#include <iterator>
#include <time.h>
#include <algorithm>

using namespace std;

#define alphabetSize 26

class Node
{
public:
    int wordsN, prefixN;
    //bool endWord;
    Node* children[alphabetSize]; // size of the alphabet

    Node()
    {
        wordsN = 0;
        prefixN = 0;
        for(int i=0; i<alphabetSize; i++)
        {
            children[i] = NULL;
        }
    }
};

void insertWord(string word, Node* nowNode) // returns true if this word is newWord
{
    for(int i=0; i<(int)word.size(); i++)
    {
        nowNode->prefixN++;

        char nowChar = word[i];
        int nowCharIndex = nowChar - 'A'; // also we can use a map for the alphabet used characters
        Node* nextCharNode = nowNode->children[nowCharIndex];

        if(nextCharNode != NULL)
        {
            nowNode = nextCharNode;
        }
        else
        {
            nextCharNode = new Node();
            nowNode->children[nowCharIndex] = nextCharNode;

            nowNode = nextCharNode;
        }
    }

    nowNode->wordsN++;
    //nowNode->endWord = true;
}

// We can also count the prefixes by returning prefixN instead of wordsN
int findWord(string word, Node* nowNode)
{
    for(int i=0; i<(int)word.size(); i++)
    {
        char nowChar = word[i];
        int nowCharIndex = nowChar - 'A'; // also we can use a map for the alphabet used characters
        Node* nextCharNode = nowNode->children[nowCharIndex];

        if(nextCharNode != NULL)
        {
            nowNode = nextCharNode;
        }
        else
        {
            return 0;
        }
    }

    return nowNode->wordsN;
    //return nowNode->endWord;
}

void removeWord(string word, Node* nowNode)
{
    for(int i=0; i<(int)word.size(); i++)
    {
        nowNode->prefixN--;

        char nowChar = word[i];
        int nowCharIndex = nowChar - 'A'; // also we can use a map for the alphabet used characters
        Node* nextCharNode = nowNode->children[nowCharIndex];

        if(nextCharNode != NULL)
        {
            nowNode = nextCharNode;
        }
        else
        {
            return;
        }
    }

    nowNode->wordsN--;
}

int main()
{
    Node* root = new Node();

    insertWord("ABC", root);
    insertWord("ABC", root);

    cout << findWord("AB", root) << endl;
    cout << findWord("ABC", root) << endl;

    return 0;
}
