#include <iostream>
#include <stdio.h>
#include <vector>
#include <queue>
#include <string>
#include <string.h>
#include <stdlib.h>
#include <map>
#include <functional>
#include <stack>
#include <math.h>
#include <iterator>

using namespace std;

int nodesN, startNode, endNode, edgesN;
vector<vector<int> > adjList; // contains a list of neighbors to certain node
                              //[weights are stored in adjMat] as we change a lot in these weights
int adjMat[200][200];         // the residual weights of edges [we add an subtract and compare to these weights] (capacity-flow)
int origianlAdjMat[200][200]; // the original edges no editing is done to this (original capacity(
bool visited[200];            // needed for BFS
int parent[200];              // needed for BFS
int INF = 1000000000;


void bfs() // we know the startNode and endNode [global variables]
{
    queue<int> q;

    visited[startNode] = true;
    // parent[s] = -1 :D
    q.push(startNode);

    while(q.empty() == false)
    {
        int nowNode = q.front();
        q.pop();

        if(nowNode == endNode)
        {
            return; // Augmenting path found :D :D
        }

        for(int i=0; i<(int)adjList[nowNode].size(); i++)
        {
            int nextNode = adjList[nowNode][i];
            if(adjMat[nowNode][nextNode] > 0 && visited[nextNode] == false) // There must be remaining capacity for the flow
            {
                visited[nextNode] = true;
                parent[nextNode] = nowNode;
                q.push(nextNode);
            }
        }
    }

    // No augmenting path found :(
    // whether we found an augmenting path or not will appear when we want to calculate the flow that this path can handle
}

int augmentPath(int nowNode, int minEdgeTillNow)
{
    if(nowNode == startNode)  // sure parent[nowNode] = -1
    {
        return minEdgeTillNow;
    }

    if(parent[nowNode] != -1)
    {
        int edgeWeight = adjMat[parent[nowNode]][nowNode];
        int minEdge = augmentPath(parent[nowNode], min(minEdgeTillNow, edgeWeight));

        adjMat[parent[nowNode]][nowNode] -= minEdge;
        adjMat[nowNode][parent[nowNode]] += minEdge;

        return minEdge;
    }
    else // No parent for this node [The Path can't reach the source)
    {
        return INF;
    }
}

long long solveMaxFlow()
{
    long long maxFlow = 0;

    while(true)
    {
        for(int i=1; i<=nodesN; i++)
        {
            visited[i] = false;
            parent[i]  = -1;   // any sentinel value
        }

        bfs(); // we know the startNode and endNode [global variables]

        int minEdge = augmentPath(endNode, INF);

        if(minEdge == INF) // No Further Augmenting path found
        {
            return maxFlow;
        }
        else
        {
            maxFlow += minEdge;
        }
    }
}

int main()
{
    cin >> nodesN;

    adjList.clear();
    adjList.resize(nodesN+1);
    for(int i=1; i<=nodesN; i++)
    {
        for(int j=1; j<=nodesN; j++)
        {
            adjMat[i][j] = 0; //Initial Value of all edges is 0 as this indicates that no flow can occur
            origianlAdjMat[i][j] = 0;
        }
    }
    
    cin >> startNode >> endNode >> edgesN;

    int first, second, weight;
    for(int i=0; i<edgesN; i++)
    {
        cin >> first >> second >> weight;

        adjList[first].push_back(second);
        adjMat[first][second] += weight;  // We add the weights to handle if there are multiple edges between same nodes
        origianlAdjMat[first][second] += weight;

        adjList[second].push_back(first);
        adjMat[second][first] += weight;  // We add the weights to handle if there are multiple edges between same nodes
        origianlAdjMat[second][first] += weight;
    }

    long long maxFlow = solveMaxFlow();

    return 0;
}
